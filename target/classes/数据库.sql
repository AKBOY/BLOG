/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 5.7.26 : Database - chuyxblog
*********************************************************************
*/


/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`chuyxblog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `chuyxblog`;

/*Table structure for table `blog` */

DROP TABLE IF EXISTS `blog`;

CREATE TABLE `blog` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `uid` int(10) NOT NULL,
  `release_date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `title` varchar(50) DEFAULT NULL,
  `small_title` varchar(1000) DEFAULT NULL,
  `category_id` int(10) DEFAULT NULL,
  `visit_count` int(10) DEFAULT '0',
  `content` text NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `blog_index` (`id`),
  KEY `bu` (`uid`),
  CONSTRAINT `bu` FOREIGN KEY (`uid`) REFERENCES `user` (`uid`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8;

/*Data for the table `blog` */

insert  into `blog`(`id`,`uid`,`release_date`,`title`,`small_title`,`category_id`,`visit_count`,`content`) values (1,1,'2020-10-02 16:14:10','反射机制','对Java反射机制的一些介绍。',1,533,'## 反射机制介绍\r\n\r\nJAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。\r\n\r\n### 获取 Class 对象的两种方式\r\n\r\n如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了三种方式获取 Class 对象:\r\n\r\n1.知道具体类的情况下可以使用：\r\n\r\n```\r\nClass alunbarClass = TargetObject.class;\r\n```\r\n\r\n但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象\r\n\r\n2.通过 `Class.forName()`传入类的路径获取：\r\n\r\n```\r\nClass alunbarClass1 = Class.forName(\"cn.javaguide.TargetObject\");\r\n```\r\n\r\n3.通过对象实例`instance.getClass()`获取：\r\n\r\n```\r\nEmployee e;\r\nClass alunbarClass2 = e.getClass();\r\n```\r\n\r\n\r\n\r\n## class对象的各种方法\r\n\r\n- getMethods();		//获取该类的所有方法  返回对象是一个Method类的数组（**Method[]**）\r\n- getMethod(String name, Class<?>... parameterTypes);          //获取指定的方法，第一个参数是方法名，其余的参数是方法入参类型的class对象\r\n\r\n> Method的方法：\r\n>\r\n> - getName();		//获取方法名字\r\n> - invoke(Object obj, Object... args);      //执行该方法，第一个参数是对应类的实例，其他参数是入参\r\n> - \r\n\r\n- getDeclaredFields();      //获取该类的所有参数	返回对象是一个Field类的数组（**Field[]**）\r\n- getDeclaredField(String FiledName);     //获取指定的参数，FiledName是参数的名字\r\n\r\n> Field的方法：\r\n>\r\n> - getName();       //获取参数名字\r\n> - set(FObject obj, Object value);    //设置参数，第一个参数是Filed类，第二个参数是设置的值\r\n\r\n\r\n\r\n==**注意：**==调用private方法和设置private参数时，需要调用`setAccessible(true)`，这是取消安全检查。\r\n\r\n**获取类修饰符**：getModifiers();  	//返回的是一个int类型的数值\r\n\r\n> 类修饰符有public、private等类型，getModifiers()可以获取一个类的修饰符，但是返回的结果是int，结合Modifier提供的方法，就可以确认修饰符的类型。\r\n>\r\n> ```。java\r\n> Modifier.is+修饰符名字();	//这里返回一个boolean值\r\n> ```\r\n\r\n## 静态编译和动态编译\r\n\r\n- **静态编译：** 在编译时确定类型，绑定对象\r\n- **动态编译：** 运行时确定类型，绑定对象\r\n\r\n> 两者的区别在于：动态编译可以最大程度的支持多态，而多态的意义在于降低代码的耦合性，因此反射的优点就显而易见了，就是解耦以及提高代码的灵活性\r\n\r\n## 反射机制的优缺点\r\n\r\n- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。\r\n- **缺点：** 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。'),(2,1,'2020-10-23 09:51:01','BIO、NIO和AIO','Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。',1,134,'## 同步与异步，阻塞与非阻塞。\r\n\r\n- **同步** ：两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在`A->B`事件模型中，你需要先完成 A 才能执行B。 再换句话说，同步调用中被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。\r\n- **异步**： 两个异步的任务完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用种一调用就返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情，\r\n\r\n**阻塞和非阻塞**\r\n\r\n- **阻塞：** 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。\r\n- **非阻塞：** 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。\r\n\r\n\r\n\r\n## BIO\r\n\r\n同步阻塞I/O模型，数据的读取写入必须阻塞在一个线程内等待其完成。\r\n\r\n### 传统BIO\r\n\r\nBIO通信（——请求——应答）模型图如下：\r\n\r\n![](http://img.chuyx.top/FuuRh7TBQ2WzIzgoeD8Y_iogw-4I)\r\n\r\n采用 **BIO 通信模型** 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在`while(true)` 循环中服务端会调用 `accept()` 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。\r\n\r\n如果要让 **BIO 通信模型** 能够同时处理多个客户端请求，就必须使用多线程（主要原因是`socket.accept()`、`socket.read()`、`socket.write()` 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 **一请求一应答通信模型** 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 **线程池机制** 改善，线程池还可以让线程的创建和回收成本相对较低。使用`FixedThreadPool` 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型（N 可以远远大于 M），下面一节\"伪异步 BIO\"中会详细介绍到。\r\n\r\n**我们再设想一下当客户端并发访问量增加后这种模型会出现什么问题？**\r\n\r\n在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。\r\n\r\n\r\n\r\n### 伪异步IO\r\n\r\n为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。\r\n\r\n采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。\r\n\r\n伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题。\r\n\r\n\r\n\r\n**BIO例题见Basic-Code/liework/src/com/IO**\r\n\r\n### 总结\r\n\r\n在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。\r\n\r\n\r\n\r\n## NIO\r\n\r\n### 简介\r\n\r\nNIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。\r\n\r\nNIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。\r\n\r\n### NIO的特性/NIO与IO区别\r\n\r\n如果是在面试中回答这个问题，我觉得首先肯定要从 NIO 流是非阻塞 IO 而 IO 流是阻塞 IO 说起。然后，可以从 NIO 的3个核心组件/特性为 NIO 带来的一些改进来分析。如果，你把这些都回答上了我觉得你对于 NIO 就有了更为深入一点的认识，面试官问到你这个问题，你也能很轻松的回答上来了。\r\n\r\n#### 1)Non-blocking IO（非阻塞IO）\r\n\r\n**IO流是阻塞的，NIO流是不阻塞的。**\r\n\r\nJava NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。\r\n\r\nJava IO的各种流是阻塞的。这意味着，当一个线程调用 `read()` 或 `write()` 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了\r\n\r\n#### 2)Buffer(缓冲区)\r\n\r\n**IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。**\r\n\r\nBuffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。\r\n\r\n在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。\r\n\r\n最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。\r\n\r\n#### 3)Channel (通道)\r\n\r\nNIO 通过Channel（通道） 进行读写。\r\n\r\n通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。\r\n\r\n#### 4)Selector (选择器)\r\n\r\nNIO有选择器，而IO没有。\r\n\r\n选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。\r\n\r\n[![一个单线程中Selector维护3个Channel的示意图]\r\n![](http://img.chuyx.top/FkxREvnbwJ00Emx3EBZPptMe7w-B)\r\n\r\n### 2.3 NIO 读数据和写数据方式\r\n\r\n通常来说NIO中的所有IO都是从 Channel（通道） 开始的。\r\n\r\n- 从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。\r\n- 从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。\r\n\r\n数据读取和写入操作图示：\r\n\r\n[![NIO读写数据的方式]\r\n![](http://img.chuyx.top/FuwG2T6aEnB9_ruOPcAqCKQTlqBf)\r\n\r\n### 2.4 NIO核心组件简单介绍\r\n\r\nNIO 包含下面几个核心的组件：\r\n\r\n- Channel(通道)\r\n- Buffer(缓冲区)\r\n- Selector(选择器)\r\n\r\n整个NIO体系包含的类远远不止这三个，只能说这三个是NIO体系的“核心API”。我们上面已经对这三个概念进行了基本的阐述，这里就不多做解释了。\r\n\r\n\r\n\r\n为什么大家都不愿意用 JDK 原生 NIO 进行开发呢？从上面的代码中大家都可以看出来，是真的难用！除了编程复杂、编程模型难之外，它还有以下让人诟病的问题：\r\n\r\n- JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%\r\n- 项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高\r\n\r\n### AIO (Asynchronous I/O)\r\n\r\nAIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\r\n\r\nAIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的，这一点可以从底层IO线程模型解释，推荐一篇文章：[《漫话：如何给女朋友解释什么是Linux的五种IO模型？》](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect) ）\r\n'),(7,1,'2020-10-13 21:15:24','HTTP协议','HTTP协议是**超文本传输协议**，用于从万维网服务器传输超文本到浏览器的传输协议。\r\n\r\n它是**基于TCP/IP通信协议**来传递数据的。\r\n\r\nHTTP协议工作于C/S（客户端/服务器）架构上。\r\n\r\n属于**应用层**，**面向对象的**协议。',1,15,'**特点：**\r\n\r\n- 简单快速\r\n- 灵活\r\n- 无连接（每次只处理一个请求）\r\n- 无状态（不保存传输的信息，==HTTP1.1版本后引入Cookie技术==）\r\n- 支持B/S、C/S架构\r\n\r\n**URL**\r\n\r\nhttp协议使用统一资源定标识符（Uniform Resources Identifiers：URI）来传输数据和建立连接。\r\n\r\nURL是一种特殊的URI，全称为统一资源定位符（Uniform Resources Locader）。它包含了用于查找某个资源所需要的所有信息。用于在互联网上确认某一处的资源\r\n\r\n组成：\r\n\r\n​	`协议部分`://`域名部分`:`端口部门`/`虚拟目录部分`/`文件名部分`?`参数部门``锚部分`\r\n\r\neg：http://localhost:8080/admin/index.html?a=1#name\r\n\r\n\r\n\r\n**请求消息Request**\r\n\r\n格式：\r\n\r\n![](http://img.chuyx.top/FhMxXzGqCFBwEVIQ8zKjiYhzrSfz)\r\n\r\n**响应消息Response**\r\n\r\n![](http://img.chuyx.top/Fi0XAENJ4HLl048fFhVl-Hq5Jypq)\r\n\r\n\r\n\r\n**HTTP状态码**\r\n\r\n1XX：消息（没看到过哈哈哈）\r\n\r\n2XX：成功\r\n\r\n3XX：重定向（再来一道面试题：你知道301和302的区别吗？都是重定向哦，答案在最后）\r\n\r\n4XX：客户端错误（检查路径，参数等）\r\n\r\n5XX：服务端错误（打开命令窗口查看错误）\r\n\r\n\r\n\r\n**HTTP工作原理**\r\n\r\n1. 客户端连接到Web服务器（先会通过DNS解析 域名找到服务端的ip地址咯，绕后通过TCP三次握手建立连接，这个我写过）\r\n2. 发送http请求\r\n3. 服务端接受请求并返回http响应\r\n4. 释放TCP连接\r\n5. 客户端浏览器解析响应正文展示到浏览器窗口'),(12,1,'2020-10-11 15:52:53','Redis的五种基本类型','Redis即远程字典服务，是一个开源的ANSI C语言编写的、支持网络、可基于内存、可持久化、key-value数据库。',7,11,'## 五种基本类型\r\n\r\n### 字符串String\r\n\r\nRedis 中的字符串是一种 **动态字符串**，这意味着使用者可以修改，它的底层实现有点类似于 Java 中的 **ArrayList**，有一个字符数组。\r\n\r\n> Redis没有使用C语言的字符串原因：\r\n>\r\n> 因为 C 语言这种简单的字符串表示方式 **不符合 Redis 对字符串在安全性、效率以及功能方面的要求**。我们知道，C 语言使用了一个长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组最后一个元素总是 `\'\\0\'`。\r\n>\r\n> 这样简单的数据结构可能会造成以下一些问题：\r\n>\r\n> - **获取字符串长度为 O(N) 级别的操作** → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组；\r\n> - 不能很好的杜绝 **缓冲区溢出/内存泄漏** 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题；\r\n> - C 字符串 **只能保存文本数据** → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 `\'\\0\'` 可能会被判定为提前结束的字符串而识别不了；\r\n>\r\n> ==ps：==**Redis 规定了字符串的长度不得超过 512 MB。**\r\n\r\n#### 字符串的基本操作：\r\n\r\n**设置和获取键值对：**set/get\r\n\r\n> 值可以使任何种类的字符串（包括二进制数据），比如在一个键下保存一张 .jpeg 的图片（记得不能超过512M）\r\n>\r\n> 当key存在的时候，set命令会覆盖掉上一次的值\r\n>\r\n> 使用exists 来查询键是否存在， 使用del 来删除键\r\n\r\n**批量设置键值对：**Mset/Mget\r\n\r\n```cmd\r\n> MGET key1 key2 key3    # 返回一个列表\r\n1) \"value1\"\r\n2) \"value2\"\r\n3) (nil)\r\n> MSET key1 value1 key2 value2\r\n> MGET key1 key2\r\n1) \"value1\"\r\n2) \"value2\"\r\n```\r\n\r\n**过期和 SET 命令扩展：**expire\r\n\r\n可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来控制缓存的失效时间。*(过期可以是任意数据结构)*\r\n\r\n> expire name n: key为name的键在n秒后被删除\r\n\r\n**等价于set + expire 的 `settex`**\r\n\r\n> settex key 5 value：设置一个key为key 值为value 并且5秒后过期的键值对\r\n\r\n**计数：**\r\n\r\n如果 value 是一个整数，还可以对它使用 `INCR` 命令进行 **原子性** 的自增操作，这意味着及时多个客户端对同一个 key 进行操作，也决不会导致竞争的情况。\r\n\r\n> Redis中字符串可以存储三种数据类型：字节串，整数，浮点数。\r\n>\r\n> 用户可以通过给定一个任意的数值，对存储着的整数或浮点数的字符串执行自增或自减的操作。\r\n>\r\n> 在有需要的情况下，Redis还会将整数转换为浮点数。\r\n>\r\n> 整数的取值范围和系统的长整数一样\r\n\r\n- incr keyName ：将键存储的值加一\r\n- decr keyName：将键存储的值减一\r\n- incrby keyName amount：将键存储的值加上amount\r\n- decrby keyName amount：将键存储的值减去amount\r\n- incrbyfloat keyName amount：将键存储的值加上**浮点数**amount。这个命令在Redis2.6之后可用\r\n\r\n==注意：==如果用户对一个不存在的key进行自增或自减，则Redis会默认key的值为 0；如果用户对一个值无法被解释成整数或浮点数的key进行自增或自减则会报错\r\n\r\n#### 处理字符串子串和二进制位的命令\r\n\r\n> - append keyName value：往keyName的值末尾加上value\r\n> - getrange keyName start end：获取keyName值的从start到end下标的子串，包括start位和end位\r\n> - setrange keyName start value：给keyName的值从start开始的子串设置新值value（有几个字符就改变几个字符）\r\n> - getbit keyName offset：获取keyName的值转变为2进制后第offset位\r\n> - setbit keyName offerset value：设置keyName的值转变为2进制后第offset位为value\r\n> - bitcount keyName [ start end]： 统计二进制位串中里面值为1的二进制位的数量，如果给定start 和 end 就只对其范围内进行统计\r\n> - bitop opration destKey keyName [keyName2......]：对一个或多个二进制位串行执行包括并（and），或（or），异或（Xor），非（not）在内的任意一种位运算操作，并将计算出来的值存入destKey\r\n\r\n\r\n\r\n### 列表list\r\n\r\n#### list基本操作\r\n\r\n> lpush list_key item [item2 item3......]：在key为list_key的列表右端插入一个或多个元素，如果没有key为list_key的列表则创建一个\r\n>\r\n> rpush list_key item2：在key为list_key的列表左端插入item，如果没有key为list_key的列表则创建一个\r\n>\r\n> lrange list_key n m：查看key为list_key的列表第n位到m位的元素，当为0 -1 时展示全部的元素\r\n>\r\n> lpop list_key / rpop list_key：弹出（查看并删除）key为list_key的列表中最 左端/右端的元素\r\n>\r\n> lindex list_key i：查看key为list_key的列表的第 i 位 元素（元素和数组差不多，从0开始）\r\n\r\n> ltrim keyName start end：对列表进行修剪，保留从start到end之间的元素（包括start和end处的元素）\r\n>\r\n> Blpop keyName1 keyName2.... timeout：从第一个非空列表中弹出最右端的元素（列表的key也会显示在命令行中），如果没有的话则在timeout秒内阻塞并等待可弹出的元素出现（==其他线程推入元素后，立即会被检测出来并弹出==）\r\n>\r\n> Brpop keyName1 keyName2... timeout：类似上\r\n>\r\n> RpopLpush sourceKey destkey timeout：弹出sourceKey列表最右端的元素并将它推入destKey最左端，如果sourceKey为空，则在timeout秒内阻塞并等待可弹出的元素出现\r\n\r\n==注意==：**在Redis里，多个命令原子的执行指的是，在这些命令中正在读取或者修改数据的时候，其他客户端不能读取或者修改相同的数据。**\r\n\r\n### 集合set基本操作\r\n\r\n**集合和列表的差异：**Redis的集合和列表都可以存储多个字符串，它们的区别在于用list可以存储多个相同的字符串，而set则通过散列列表来保证自己存储的每个字符串都是各不相同的。\r\n\r\n> sadd set_key item [ item2 item3....]：给key为set__key的集合添加一个或多个元素（返回n则表示添加n个元素成功，返回0则表示集合中已有了这个元素）\r\n>\r\n> smembers set_key：查看key为set_key的集合的所有值（如果值有很多速度很慢）\r\n>\r\n> sismeber set_key item：检查item是否在key为set_key的集合中存在返回1，不存在返回2\r\n>\r\n> srem set_key item：移出key为set_key集合中的item，返回的是移除的数量\r\n\r\nRedis的集合以无序的方式来存储多个各不相同的元素，用户可以快速的对集合执行添加元素操作，移除元素操作以及检查一个元素是否重复存在于集合中。\r\n\r\n> srem set_key item [item2 item3.....]：给key为set__key的集合移除一个或多个元素（返回n则表示移除n个元素成功，返回0则表示集合无元素移除）\r\n>\r\n> sismember set_key item：检查item是否存在于集合set_key中，存在返回1，不存在返回0\r\n>\r\n> scard set_key：返回集合set_key中包含的数量\r\n>\r\n> smembers set_key：返回set_key集合中包含的所有元素\r\n>\r\n> srandmember set_key [count]：从集合中随机返回count个元素，默认是一个\r\n>\r\n> spop set_key：随机从集合中移除一个元素并返回移除的元素\r\n>\r\n> smove source_key dest_key item：如果集合中source_key中包含item元素，则从source_key中移除item元素，并将item元素添加到集合dest_key中，如果item被成功移除返回1，否则返回0\r\n>\r\n> sdiff setKey1 [setKey2, setKey3]：返回存在于第一个集合不存在于其他集合的数字，数学上的差集\r\n>\r\n> sdiffstore destKey setKey1 [setKey2, setKey3]：将后者的差集存在destKey集合中\r\n>\r\n> sinter setKey1 [setKey2, setKey2.......]：返回那些同时存在所有集合中的元素，交集\r\n>\r\n> sinterstore destKey setKey1 [setKey2, setKey3.....]：将后者的交集存在destKey集合中\r\n>\r\n> sunion setKey1 [setKey2, setKey3....]：返回那些至少存在一个集合中的元素，并集\r\n>\r\n> sunionstore destKey setKey1 [setKey2, setKey3.....]：将后者的并集存到destKey中\r\n\r\n### 散列Hash\r\n\r\nRedis的散列是可以存储多个键值对。和redis一样，散列存储的值既可以是字符串也可以是数字值。\r\n\r\n> hset hash_key sub_key1 value1：给key为hash_key的散列表添加一个key为sub_key1,值为value1的键值对\r\n>\r\n> hget hash_set sub_key1：查看key为hash_set散列的key为sub_key1的值\r\n>\r\n> hgetall hash_key：查看key为hash_key散列的所有键值对\r\n>\r\n> hdel hash_key sub_key1：删除key为hash_key的散列的键为sub_key1的键值对，返回1成功\r\n\r\n> hmget hash_key sub_key1 [setKey2, setKey3.....]：从散列中获取一个或多个键的值\r\n>\r\n> hmget hash_key sub_key1 value1 [setKey2 value2, setKey3 value3.....]：在散列中一次设置多个键值对\r\n>\r\n> hdel hash_key sub_key1 [setKey2, setKey3.....]：删除散列中一个或多个键值对\r\n>\r\n> hlen hash_key：获取当前散列键值对的数量\r\n\r\n> hexists hashKey sub_key：检查sub_key键是否存在于hashKey散列中，返回1存在，否则不存在\r\n>\r\n> hkeys hash_key ：获取hash_key 散列的所有键\r\n>\r\n> hvalue hash_key：获取hash_key散列中的所有值\r\n>\r\n> hincrby hash_key key increment：在hash_key散列上为key的值加上**整数**increment（如果值不是整数型则会报错）\r\n>\r\n> hincrbyfloat hash_key key increment：在hash_key散列上为key的值加上**浮点数**increment（如果值不是浮点数型则会报错）\r\n\r\n### 有序集合zset\r\n\r\nzset也用于存储键值对，它的键被称之为成员（member），值被称为分值（score），分值必须为浮点数。\r\n\r\n有序集合是redis里唯一一个既可以根据成员访问元素，也可以根据分值和分值的排列顺序来访问元素的结构。\r\n\r\n> zadd zset_key  728 member1：在key为zset_key的有序集合中加一个成员为member1，分值为728的键值对\r\n>\r\n> zrange zset_key n m withscores：查看key为zset_key的有序集合n 到 m 的成员和分值（0 -1 就是查看所有）\r\n>\r\n> zrangebyscore zset_key n m withscores：查看分值在n到m 之间的成员和分值\r\n>\r\n> zrem zset_key member1：删除key为zset_key的有序集合中成员为member的成员和分值	\r\n\r\n> zcard zset_key：返回有序集合成员的数量\r\n>\r\n> zincrby zset_key increment member ：给key为zset_key的有序集合中成员为member的分值加上整数increment\r\n>\r\n> zcount zset_key min max：返回分值在min和max之间的成员数量（包含min和max）\r\n>\r\n> zrank zset_key member：返回成员member在有序集合中的排名\r\n>\r\n> zscore zset_key member：返回成员的分值\r\n\r\n> zrevrank zset_key member：返回有序集合中成员的排名，成员按照分值从大到小排序（以下有关排名都是）\r\n>\r\n> zrevrange zset_key start stop [withscores]：返回有序集合中排名在start，stop中的成员\r\n>\r\n> zrangebyscore zset_key  min max [withscores]：返回有序集合中分值介于min和max之间的所有成员\r\n>\r\n> zrevrangebyscore zset_key  max min [withscores]：返回有序集合中分值介于max和min之间的所有成员\r\n>\r\n> zremrangebyrank zset_key start stop：移除有序集合中排名介于start和stop 之间的成员\r\n>\r\n> zremrangebyscore zset_key min max：移除有序集合中分值介于min和max之间的成员\r\n>\r\n> zinterstore dest_key zsetkey1 keyName1 [KeyName2...]：交集\r\n>\r\n> zunionstore dest_key zsetkey1 keyName1 [KeyName2...]：并集'),(14,1,'2020-10-13 21:39:00','七牛云上传工具类','七牛云上传工具类代码',7,13,'```java\r\npackage com.chuyx.utils;\r\n\r\nimport com.google.gson.Gson;\r\nimport com.qiniu.common.QiniuException;\r\nimport com.qiniu.common.Zone;\r\nimport com.qiniu.http.Response;\r\nimport com.qiniu.storage.Configuration;\r\nimport com.qiniu.storage.UploadManager;\r\nimport com.qiniu.storage.model.DefaultPutRet;\r\nimport com.qiniu.util.Auth;\r\nimport org.springframework.web.multipart.MultipartFile;\r\nimport org.testng.annotations.IConfigurationAnnotation;\r\n\r\n/**\r\n * 文件上传工具\r\n */\r\npublic class UploadUtil {\r\n\r\n    /**\r\n     * 上传到七牛云\r\n     * @param file 上传的图片\r\n     * @return 七牛云中图片的名字\r\n     */\r\n    public static String uploadQiniu(MultipartFile file) {\r\n        //构造一个带指定Zone对象的配置类\r\n        Configuration cfg = new Configuration(Zone.zone2());\r\n        //...其他参数参考类注释\r\n        UploadManager uploadManager = new UploadManager(cfg);\r\n        //...生成上传凭证，然后准备上传\r\n        String accessKey = \"5ngLMovI40oojUYkdSvnORe0JtpY4yH3zjpB7yjr\";\r\n        String secretKey = \"FvDyWzPUobu5ctFofYFfyah91vAXcOm7CBv1nbhz\";\r\n        //存储空间的名字\r\n        String bucket = \"chuyx\";\r\n        //默认不指定key的情况下，以文件内容的hash值作为文件名\r\n        String key = null;\r\n        Auth auth = Auth.create(accessKey, secretKey);\r\n        String upToken = auth.uploadToken(bucket);\r\n        try {\r\n            Response response = uploadManager.put(file.getBytes(), key, upToken);\r\n            //解析上传成功的结果\r\n            DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);\r\n            return putRet.key;\r\n        } catch (QiniuException ex) {\r\n            Response r = ex.response;\r\n            System.err.println(r.toString());\r\n            try {\r\n                System.err.println(r.bodyString());\r\n            } catch (QiniuException ex2) {\r\n                //ignore\r\n            }\r\n        } catch (Exception ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```'),(21,1,'2021-03-14 11:00:24','POJO 数据传输对象转换方案','在公司级开发标准中，程序内部使用DTO，传输给前端使用VO，数据库交互使用PO，其实这些字段都是相差不大的，怎么方便的完成这个数据传输对象的转换捏？本文介绍一下dozer的使用。',1,2,'利用这个依赖\r\n<dependency>\r\n<groupId>net.sf.dozer</groupId>\r\n<artifactId>dozer</artifactId>\r\n<version>5.5.1</version>\r\n</dependency>\r\n\r\n导入bean:\r\n将DozerBeanMapper导入bean，再写一个工具类，使之可以直接使用\r\n\r\n示例：\r\nDozerBeanMapper dozerBeanMapper = new DozerBeanMapper();\r\ndozerBeanMapper.map(publishBlogDTO, NewBlogDTO.class);\r\n\r\n工具类：\r\npackage com.chuyx.utils;\r\n\r\nimport org.dozer.DozerBeanMapper;\r\nimport org.springframework.util.CollectionUtils;\r\n\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\n\r\n/**\r\n * @author yasir.chu\r\n * @date 2020/12/19\r\n **/\r\n\r\npublic class DozerUtil {\r\n\r\n    public static DozerBeanMapper mapper = new DozerBeanMapper();\r\n\r\n    /**\r\n     * 单个数据对象转化\r\n     *\r\n     * @param source      数据源对象\r\n     * @param targetClass 数据目标对象字节码\r\n     * @param <T>         数据传输对下个的类的字节码\r\n     * @return 转化好了之后的对象\r\n     */\r\n    public static <T> T map(java.lang.Object source, java.lang.Class<T> targetClass) {\r\n        if (source != null) {\r\n            return mapper.map(source, targetClass);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * 单个数据对象转化\r\n     *\r\n     * @param sources     数据源对象列表\r\n     * @param targetClass 数据目标对象字节码\r\n     * @param <T>         数据传输对下个的类的字节码\r\n     * @return 转化好了之后的对象列表\r\n     */\r\n    public <T> List<T> mapList(List<?> sources, Class<T> targetClass) {\r\n        if (!CollectionUtils.isEmpty(sources)) {\r\n            return sources.stream().map(source -> mapper.map(source, targetClass)).collect(Collectors.toList());\r\n        }\r\n        return Collections.emptyList();\r\n    }\r\n\r\n}');

/*Table structure for table `category` */

DROP TABLE IF EXISTS `category`;

CREATE TABLE `category` (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `name` varchar(100) DEFAULT NULL COMMENT '类别名',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8 COMMENT='类别表';

/*Data for the table `category` */

insert  into `category`(`id`,`name`) values (1,'JAVA'),(2,'SPRING'),(3,'数据结构与算法'),(4,'架构'),(5,'运维'),(6,'P&L'),(7,'其他'),(9,'数据库');

/*Table structure for table `comments` */

DROP TABLE IF EXISTS `comments`;

CREATE TABLE `comments` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `uid` int(10) NOT NULL,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `content` varchar(100) DEFAULT NULL,
  `parent_id` int(10) DEFAULT NULL,
  `blog_id` int(10) NOT NULL,
  `author_one` varchar(20) DEFAULT NULL,
  `author_twe` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `cb` (`blog_id`),
  KEY `cu` (`uid`),
  CONSTRAINT `cu` FOREIGN KEY (`uid`) REFERENCES `user` (`uid`)
) ENGINE=InnoDB AUTO_INCREMENT=102 DEFAULT CHARSET=utf8;

/*Data for the table `comments` */

insert  into `comments`(`id`,`uid`,`create_time`,`content`,`parent_id`,`blog_id`,`author_one`,`author_twe`) values (28,1,'2020-10-06 17:22:39','我是作者！！！！！',0,1,NULL,NULL),(29,1,'2020-10-11 16:19:38','这个写的很不错诶',0,12,NULL,NULL),(34,1,'2020-10-13 21:18:20','写的真好',0,7,NULL,NULL),(35,1,'2021-01-27 22:26:58','还不错哦',0,2,NULL,NULL),(70,1,'2021-02-08 18:08:46','回家测试',0,2,NULL,NULL),(94,1,'2021-03-14 11:01:30','本人常常使用，很方便',0,21,NULL,NULL),(99,1,'2021-04-15 10:50:41','12',0,2,NULL,NULL),(100,1,'2021-04-15 13:59:35','1',0,1,NULL,NULL),(101,1,'2021-05-12 00:25:55','欢迎找我交流技术',100,1,'chuyx','chuyx');

/*Table structure for table `log` */

DROP TABLE IF EXISTS `log`;

CREATE TABLE `log` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `uid` int(10) NOT NULL DEFAULT '' COMMENT '用户名',
  `event` varchar(10) DEFAULT NULL COMMENT '事件',
  `connent` varchar(200) DEFAULT NULL,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=36 DEFAULT CHARSET=utf8;

/*Data for the table `log` */

insert  into `log`(`id`,`uid`,`event`,`connent`,`create_time`) values (1,11,'博主申请','用户11申请博主资格','2020-10-12 22:39:54'),(2,11,'博主申请','用户11申请博主资格','2020-10-12 23:23:45'),(3,11,'博主申请','用户11申请博主资格','2020-10-12 23:28:45'),(4,11,'博主申请','用户11申请博主资格','2020-10-12 23:29:09'),(5,7,'博主申请','用户7申请博主资格','2020-10-12 23:34:29'),(6,7,'博主申请','用户7申请博主资格','2020-10-12 23:35:39'),(7,7,'博主申请','用户7申请博主资格','2020-10-12 23:35:48'),(8,7,'博主申请','用户7申请博主资格','2020-10-12 23:36:20'),(9,9,'博主申请','用户9申请博主资格','2020-10-12 23:39:18'),(10,9,'博主申请','用户9申请博主资格','2020-10-12 23:39:29'),(11,9,'博主申请','用户9申请博主资格','2020-10-12 23:40:04'),(12,11,'博主申请','用户11申请博主资格','2020-10-12 23:47:33'),(13,11,'博主申请','用户11申请博主资格','2020-10-12 23:51:13'),(14,11,'博主申请','用户11申请博主资格','2020-10-12 23:53:38'),(15,7,'博主申请','用户7申请博主资格','2020-10-12 23:56:33'),(16,7,'博主申请','用户7申请博主资格','2020-10-12 23:58:54'),(17,7,'博主申请','用户7申请博主资格','2020-10-12 23:59:11'),(18,9,'博主申请','用户9申请博主资格','2020-10-13 00:01:12'),(19,9,'博主申请','用户9申请博主资格','2020-10-13 00:02:57'),(20,11,'博主申请','用户11申请博主资格','2020-10-13 21:21:08'),(21,26,'博主申请','用户26申请博主资格','2021-03-14 14:12:49'),(22,20,'博主申请','用户20申请博主资格','2021-03-14 15:09:37'),(23,27,'博主申请','用户27申请博主资格','2021-03-14 15:17:02'),(24,26,'博主申请','用户26申请博主资格','2021-03-14 15:21:33'),(25,26,'博主申请','用户26申请博主资格','2021-03-14 15:26:04'),(26,26,'博主申请','用户26申请博主资格','2021-03-14 15:35:47'),(27,27,'博主申请','用户27申请博主资格','2021-03-14 15:37:59'),(28,26,'博主申请','用户26申请博主资格','2021-03-14 15:39:07'),(29,26,'博主申请','用户26申请博主资格','2021-03-14 15:44:42'),(30,26,'博主申请','用户26申请博主资格','2021-03-14 15:46:13'),(31,27,'博主申请','用户27申请博主资格','2021-03-14 15:47:05'),(32,11,'博主申请','用户11申请博主资格','2021-04-15 14:07:34'),(33,11,'博主申请','用户11申请博主资格','2021-04-18 17:05:57'),(34,29,'博主申请','用户29申请博主资格','2021-04-21 13:53:18'),(35,29,'博主申请','用户29申请博主资格','2021-04-28 13:33:53');

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `uid` int(10) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `uname` varchar(50) NOT NULL DEFAULT '' COMMENT '用户名',
  `password` varchar(100) NOT NULL DEFAULT '' COMMENT '用户密码',
  `brith` date DEFAULT NULL COMMENT '用户生日',
  `sex` int(1) NOT NULL DEFAULT '0' COMMENT '用户性别 0男1女',
  `email` varchar(32) NOT NULL DEFAULT '' COMMENT '用户邮箱',
  `phone` varchar(16) NOT NULL DEFAULT '' COMMENT '用户电话',
  `capacity` int(2) NOT NULL DEFAULT '0' COMMENT '用户级别 -1 正在申请博主的 0 普通用户 1博主 2超级管理员',
  `logged` varchar(64) NOT NULL DEFAULT '' COMMENT '用户签名 暂未用',
  `head_pic` varchar(128) NOT NULL DEFAULT 'http://img.chuyx.top/FtijrH85AbdHe1rPpIuAxgA6u5wD' COMMENT '用户头像地址',
  `del` int(2) NOT NULL DEFAULT '0' COMMENT '逻辑删除 0表示正常',
  PRIMARY KEY (`uid`),
  UNIQUE KEY `uname` (`uname`)
) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8 COMMENT='用户表|chuyx';

/*Data for the table `user` */

insert  into `user`(`uid`,`uname`,`password`,`brith`,`sex`,`email`,`phone`,`capacity`,`logged`,`head_pic`,`del`) values (1,'chuyx','$2a$10$4GK.yZHjm/CHTPmDrjcVXOPcWELSPY9LCgZbZ4kO4kTDfv2m.vbj2','1998-07-12',1,'1666016977@qq.com','13107021813',2,'','http://img.chuyx.top/FtijrH85AbdHe1rPpIuAxgA6u5wD',0),(29,'cc','$2a$10$qkdpFZAyCfptrV8XWu3Hd.IdvHwb2vrTfi3ND8Q6nHqEyU7OeP49e','2021-04-16',0,'1666016977@qq.com','18274005949',-1,'11213123123123213213123123123213123123','http://img.chuyx.top/FtijrH85AbdHe1rPpIuAxgA6u5wD',0);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
